class Solution:
    def longestPalindrome(self, s: str) -> str:
        max_str = ''
        for i in range(len(s)): # 起点
            if len(max_str) > (len(s) - i):
                break
            for j in range(i,len(s)): # 终点
                if self.isPalindrome(s[i:j+1]) and (j+1-i) > len(max_str):
                    max_str = s[i:j+1]
        return max_str

    def isPalindrome(self, s:str) -> bool:
        return s[:int(len(s)/2)] == s[::-1][:int(len(s)/2)]
        
思路：一开始考虑中心扩展算法，对于子字符串如何遍历没有考虑清楚，随后考虑暴力法，但提交后超时
方案：考虑使用其他方法解决
知识点：1/字符串切片起止问题 [start:end:step] 字符串由start起，终点为 end-1 ！非 end，步进为 step。
          当start/end入参为负时表示从相反方向开始

       2/字符串倒序问题
          当step为负时表示倒序，但是当需要实现倒序截取时，start > end  并且注意 start为实际的start end 为end+1 但无法遍历至起点
          建议使用s[-1][start:end]的方式实现倒序截取
       
       3/取整方法
         向下取整 int()
         四舍五入 round()
         向上取整 import math 
                 math.ceil(3.25) 

其他：

动态规划 down-up 1.0版本 可能内存超限
class SolutionDP:
    def longestPalindrome(self,s:str) -> str:
        if len(s) < 2:
            return s
        p = [[-1] * len(s) for i in range(len(s))]
        for i in range(len(s)):
            p[i][i] = True
        for i in range(len(s)-1):
            if s[i] == s[i+1]:
                p[i][i+1] = True
            else:
                p[i][i+1] = False

        self.__longestPalindrome_aux(p, s, 0, len(s)-1)

        b=e=a=0
        for i in range(len(s)):
            for j in range(1+i,len(s)):
                if p[i][j] == True and j-i > a:
                    a = j -i
                    b = i
                    e = j
        return s[b:e+1]


    def __longestPalindrome_aux(self,p,s:str,start:int,end:int):
        maxstart = 0
        maxend = 0
        if p[start][end] != -1:
            return p[start][end]
        for i in range(3,end-start+2): # 总回文长度
            for j in range(start,end-i+2): # 子字符串起点
                b = j
                e = j+i-1 #str end 标识 -1  代表从0开始的end编号
                p[b][e] = self.__longestPalindrome_aux(p,s,b+1,e -1) and s[b] == s[e]
                if p[b][e]:
                    if e - b > maxend-maxstart:
                        maxstart = b
                        maxend = e
                        ans=s[maxstart:maxend+1]
                else:
                    p[b][e] = False
        return p[start][end]

