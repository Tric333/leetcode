1/由递推表达式转为 递归模式代码
  以01背包问题为例
  递推表达式:  F(i,j) = 1: Max{F(i-1,j) , F(i-1,j-W[i]) + V[i]}   //j>=W[i]
                       2: F(i-1,j)                               //j< W[i]
                       
  迭代三要素:  1/终止条件:找到F(i,j)  //转化未 F(i,j) != None  > 0  ... 等
              2/过程    :val = 1: Max{Fun(i-1,j) , Fun(i-1,j-W[i]) + V[i]}   //j>=W[i]
                               2: Fun(i-1,j)                                 //j< W[i]
                         F(i,j) = val
              3/返回值  :F(i,j)
    重要:1/过程中的F()均转化为使用当前函数的返回值
         2/过程中的val必须赋值给F(i,j)不能直接返回
         3/为递归完整性F(i,j),V[i],W[i] 均需要设置哑元
         4/不要局限于当前对象与前一表格的关系：338比特位计数
#coding='utf
import copy
class Knapsack():
    def __init__(self,w,v,F):
        self.w = w
        self.v = v
        self.F = copy.deepcopy(F)
    def MFupdown(self,kinds,weight):
        if self.F[kinds][weight] == None: #未初始化的数据进行递归求解
            if weight < self.w[kinds]: # weight = 0时的状态在初始化时已经设置未0 不会进入该循环
                value = self.MFupdown(kinds-1,weight)
            else:
                value = max(self.MFupdown(kinds-1,weight), self.MFupdown(kinds-1,weight-self.w[kinds]) + self.v[kinds])
            self.F[kinds][weight] = value
        return self.F[kinds][weight]

    def downup(self,kinds,weight):
        for i in range(1,kinds+1):
            for j in range(1,weight+1):
                if self.w[i] > j:
                    self.F[i][j] = self.F[i-1][j]
                else:
                    self.F[i][j] = max(self.F[i-1][j], self.F[i-1][j-self.w[i]]+self.v[i])
        print(self.F)
        return self.F[-1][-1]

    def findcmp(self,weight):
        kinds = len(self.F)-1
        res = []
        for i in range(kinds,-1,-1):
            if weight >= self.w[i]:
                if self.F[i-1][weight] < self.F[i-1][weight-self.w[i]] + self.v[i]:
                    res.append(i)
                    weight -= self.w[i]
        return res

if __name__=='__main__':
    weights = [0,2,1,3,2]
    values = [0,12,10,10,15]
    weight = 6
    F = [ [None] * (weight+1) for _ in range(len(values))]
    for i in range(len(values)):
        F[i][0] = 0
    for i in range(weight+1):
        F[0][i] = 0
    a = Knapsack(weights,values,F)
    print(a.downup(len(values)-1,6))
    print(a.findcmp(6))
