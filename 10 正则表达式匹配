#coding=utf-8
class Solution:
    def isMatch(self, s: str, p: str) -> bool:
        dp = [ False for _ in range(len(s))]
        #匹配模式 0 - 正常匹配 1 .*匹配 2 c*匹配
        p_mode = 0
        p_left=0

        if len(s) == 0:
            return True
        for s_left in range(len(s)):
            #第一次匹配
            if s_left == 0 and (p.find(s[s_left]) or p.find('.')):
                dp[s_left] = True
                if p.find('.') == -1:
                    p_left = p.find(s[s_left])
                elif p.find(s[s_left]) == -1:
                    p_left = p.find('.')
                else:
                    p_left = min(p.find(s[s_left]),p.find('.'))
            else:
                if p_left + 1 < len(p):
                    #正常匹配
                    if (dp[s_left - 1] and p[p_left+1] == s[s_left]):
                        dp[s_left] = True
                        p_left+=1
                    # .* 匹配
                    elif p[p_left+1] == '.' or (p[p_left] == '.'and p[p_left + 1] == '*'):
                        dp[s_left] = True
                    #  c*匹配
                    elif p[p_left] == s[s_left] and p[p_left+1] == '*':
                        dp[s_left] = True
                    elif p_left +2 < len(p) and p[p_left+2] == s[s_left]:
                        dp[s_left] = True
                        p_left+=2
                    elif p[p_left+1] == '.':
                        dp[s_left] = True
                        p_left+=1


        return False not in dp

1.0通过用例338/447

#coding=utf-8
class Solution:
    def isMatch(self, s: str, p: str) -> bool:
        dp = [ False for _ in range(len(s))]
        p_mode = 0
        s_left = 0
        if len(s) == 0:
            return True
        #用p匹配s -> 遍历p 当p满足s且p已至列尾时返回成功
        for p_left in range(len(p)):
            if s_left == len(s):
                break

            if s[s_left] == p[p_left] or p[p_left] == '.':
                dp[s_left] = True
            elif s[s_left] == p[max(0,p_left - 1)] and p[p_left] == '*':
                dp[s_left] = True
                p_left -=1
            elif '.' == p[max(0,p_left - 1)] and p[p_left] == '*':
                dp[s_left] = True
                p_left -=1

            if p[p_left].isalnum() and dp[s_left] != True:
                s_left+=1
            elif dp[s_left] == True:
                s_left+=1

        return False not in dp
思路：先按照区分匹配模式的方式进行，走一步看一步，代码很乱

1.1 通过用例370/447
class Solution:
    def isMatch(self, s: str, p: str) -> bool:
        # p 预处理 a*a -> a*
        for i in range(2,len(p)):
            if p[i-2] == p [i] and p[i-1] == '*':
                p = p[:i-2] + 2 * p[i] + '*' + p[i+1:]
        dp = [ False for _ in range(len(s))]
        dp_visit = [ False for _ in range(len(p))]
        if len(s) == 0 and p == s:
            return True
        #用p匹配s -> 遍历p 当p满足s且p已至列尾时返回成功

        p_left = 0
        s_left = 0
        while(p_left < len(p)):
            if s_left == len(s):
                break

            if s[s_left] == p[p_left] or p[p_left] == '.':
                dp[s_left] = True
                dp_visit[p_left] = True
            elif (s[s_left] == p[max(0,p_left - 1)]or p[max(0,p_left - 1)] == '.') and p[p_left] == '*':
                dp[s_left] = True
                dp_visit[p_left] = True
                p_left -=1
            elif '.' == p[max(0,p_left - 1)] and p[p_left] == '*':
                dp[s_left] = True
                dp_visit[p_left] = True
                p_left -=1
            if dp[s_left] == True:
                s_left+=1

            p_left +=1
        #遍历完s但未遍历完p
        if len(p) < 1:
            return False not in dp
        else:
            return (False not in dp) and (dp_visit[-1] != False)
